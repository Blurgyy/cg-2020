# Assignment 1

## 测试环境

OS: Arch Linux (5.10.6-zen1-1-zen)
g++: 10.2.0
CMake: 3.19.3

## 使用方法

编译: 进入文件夹后执行

```shell
$ make
```

或者

```shell
$ cmake -S . -B build && cd build && make
```

编译得到的二进制可执行文件为 `build/zbuffer`.

要执行可执行文件, 需要一个**完全由三角形组成的** `obj` 格式的模型文件, 使用方式是把模型文件的路径作为参数:

```shell
$ ./build/zbuffer model.obj
```

执行后, 程序会用面片的法向确定面片的颜色, 并统计三种绘制方式在绘制时 (不包含建立层次 zbuffer 和场景八叉树的时间) 所需时间并将信息输出到 `stdout`, 同时保存三个 `ppm` 格式的图片.

### 参数

直接执行 `./build/zbuffer` 而不提供参数, 程序将输出可选参数并退出.

- `-h|--help` 显示可选参数并退出.
- `-r|--resolution <WxH>` 指定输出图像的分辨率, 默认为 1920x1080.
- `-f|--field-of-view <fov>` 指定绘制时相机在 `y` 方向的视角 (度), 默认为 45.
- `-o|--output <path>` 指定保存的图像文件名, 默认为 `zbuffer.ppm`.

## 实验

进行了三次实验, 分别对比了不同大小的输入模型对加速效果的影响; 不同的相机视角对加速效果的影响, 不同分辨率对加速效果的影响.  每次实验中都先去掉了场景中不朝向相机的面片 (face culling).

### 实验一: 不同大小的模型

实验中输出图像的分辨率为 1920x1080, 绘制时的相机视角由场景八叉树的根节点所表示的立方体确定 (根据场景生成的默认视角), 程序的输入模型不同.

|绘制方式|spaceship (55120 个面片)|bedroom (2249813 个面片)|
|:---:|:---:|:---:|
|naive|`136`ms|`790`ms|
|层次 zbuffer|`161`ms (`+18.38%`)|`750`ms (`-5.06%`)|
|层次 zbuffer + 场景八叉树|`166`ms (`+22.06%`)|`776`ms (`-1.77%`)|

||spaceship (55120 个面片)|bedroom (2249813 个面片)|
|:---:|:---:|:---:|
|绘制结果|![][fig:exp1-spaceship]|![][fig:exp1-bedroom]|

### 实验二: 不同相机视角

实验中输出图像的分辨率为 1920x1080, 使用的都是 bedroom 模型 (2249813 个面片), 绘制时的相机视角不同 (都不是默认视角).  视角 1 是直接看房间内的物体, 这样房间内的物体几乎都可以看到; 视角 2 是在天花板外看向房间内, 这样房间内的物体几乎都被遮挡.

||视角 1| 视角 2|
|:---:|:---:|:---:|
|naive|`545`ms|`1291`ms|
|层次 zbuffer|`624`ms (`+14.50%`)|`1195`ms (`-7.43%`)|
|层次 zbuffer + 场景八叉树|`674`ms (`+23.67%`)|`1200`ms (`-7.05%`)|

||视角 1|视角 2|
|:---:|:---:|:---:|
|绘制结果|![][fig:exp2-viewpoint1]|![][fig:exp2-viewpoint2]|

### 实验三: 不同分辨率

实验中使用的都是 bedroom 模型 (2249813 个面片), 使用默认视角, 输出图像的分辨率不同.

||1024x768|1920x1080|3840x2160|
|:---:|:---:|:---:|:---:|
|naive|`488`ms|`779`ms|`2558`ms|
|层次 zbuffer|`441`ms (`-9.63%`)|`748`ms (`-3.98%`)|`2580`ms (`+0.86%`)|
|层次 zbuffer + 场景八叉树|`439`ms (`-10.04%`)|`753`ms (`-3.33%`)|`2576`ms (`+0.70%`)|

|||1920x1080|3840x2160|
|:---:|:---:|:---:|:---:|
|绘制结果|![][fig:exp3-1024x768]|![][fig:exp3-1920x1080]|![][fig:exp3-3840x2160]|

## 结果分析

1. 从实验一的结果中可以看出, 层次 zbuffer 和场景八叉树对绘制的加速效果与模型的复杂度有正相关的关系.  因为随着场景的复杂度的增加, 面片与面片间的遮挡会越来越多, 层次 zbuffer 是在图像空间进行 early reject, 场景八叉树是在景物空间进行 early reject, 故面片间的遮挡增加后, 这两种加速方法的效果会更明显.
2. 从实验二的结果中可以看出, 当相机视角恰好处在能够让景物出现较大遮挡的方位时, 层次 zbuffer 和场景八叉树的加速效果会更好, 仍然是因为这两种方法是通过 early reject 那些必然被遮挡的物体而实现的.
3. 从实验三的结果中可以看出, 随图像分辨率的增加, 层次 zbuffer 和场景八叉树的加速效果逐渐下降.  这里的原因主要是层次 zbuffer 需要在图像空间建立四叉树, 图像空间的分辨率上升后, 四叉树深度增加, 会增加判断面片是否被 early reject 的常数复杂度, 造成加速效果下降.

## 数据结构说明

### 层次 zbuffer

这是在图像空间建立的四叉树, 如果一个面片的深度远于所在的四叉树节点的最远深度,
说明这个面片必定完全不可见, 可以安全忽略这个面片的绘制, 实现 early rejection.

相关文件: [Pyramid.cpp](./include/Pyramid.cpp), [Zbuf.cpp](./include/Zbuf.cpp)

### 场景八叉树

这是在景物空间建立的八叉树, 每个节点是一个立方体, 根节点的立方体大小为刚好覆盖
整个场景的立方体大小, 当一个面片存在于某个立方体的划分平面上时, 就把这个面片认
为是立方体所包含的面片, 如果当前立方体被判断可见或部分可见, 就要对这个立方体包
含的面片进行绘制, 然后对这个节点的所有子节点进行递归判断可见性.

相关文件: [Scene.cpp](./include/Scene.cpp)

[fig:exp1-spaceship]: ./media/exp1/spaceship.png
[fig:exp1-bedroom]: ./media/exp1/bedroom.png

[fig:exp2-viewpoint1]: ./media/exp2/viewpoint1.png
[fig:exp2-viewpoint2]: ./media/exp2/viewpoint2.png

[fig:exp3-1024x768]: ./media/exp3/1024x768.png
[fig:exp3-1920x1080]: ./media/exp3/1920x1080.png
[fig:exp3-3840x2160]: ./media/exp3/3840x2160.png

> Author: Blurgy <gy@blurgy.xyz>
> Date:   Jan 14 2021, 14:58 [CST]
